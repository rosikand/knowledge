{"title":"Week 2, Lecture 1 - Transfer Learning + Start of Meta-Learning","markdown":{"yaml":{"categories":["lecture"],"format":{"html":"default","pdf":"default","docx":"default"}},"headingText":"Week 2, Lecture 1 - Transfer Learning + Start of Meta-Learning","containsRefs":false,"markdown":"\n\n\n## Transfer learning \n\n\n> üçé **Transfer learning**: Solve target task ùíØ after solving source task(s) b ùíØa\nby transferring knowledge learned from ùíØa. \n \n\n### How is it different from mult-task? \n\n- MT: solve multiple tasks ($\\mathscr{T}_1, \\cdots, \\mathscr{T}_T$) at once: $\\min _\\theta \\sum_{i=1}^T \\mathscr{L}_i\\left(\\theta, \\mathscr{D}_i\\right)$. \n- TL: Solve target task ùíØ after solving source task(s) b ùíØa\nby transferring knowledge learned from ùíØa. \n    - Assumption: cannot access data ùíü during transfer. (**data is separate**). \n\n- Good to use TL over MT when \n  - More data in source task than target task \n  - Don't care about solving tasks at the same time \n  - Pre-trained weights for source task are available (e.g., pre-training on imagenet)\n- In TL, we don't need to solve tasks at the same time... just adaption. \n- In this sense: transfer learning is a valid solution to multi-task learning (but not vice versa).\n  - We can do multiple tasks in TL but MT doesn't *transfer* represenations over. \n  \n\n### Transfer learning via fine-tuning\n\nMost common way to do TL: pre-training the weights for init purposes. Then use traditional gradient steps to update the parameters. \n\n<p align='center'>\n    <img alt=\"picture 1\" src=\"https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/f256d0d3566f83dd218f87ef8c32c048dc81e89d815fe7d5a5f503dfd2440075.png\" width=\"300\" />  \n</p>\n\nIdea is that you can pre-learn just *general* image features for example and then use this features when training on a new task. This applies for example, even when you pre-train using ImageNet for a medical image task. \n\n- Question: criterion for when TL will work/helpful?\n  - Difficult, open question, some general common wisdom though (i.e., two medical tasks that are related... not hard rule though). \n- Where to get pre-trained params?\n  - ImageNet\n  - Large language corpora\n\n\n- Mathematical perspective: we have non-convex function we need to optimize. By pre-training, we can start in a better \"basin\" in the loss landscape. \n\n#### Common design choices (common wisdom) \n\nAbove, we specified the general framework for pre-training/fine-tuning. But there exists many variants to this framework. The general idea is that we want to preserve a good balance of the old data while learning from the new data. In this sense, we can choose, for example, how many layers to freeze when training. Here are some common params: \n\n- Motivation: typically you need to adjust the last layer for your task. This means we need to randomly init the last layer. However, during backprop, these random weights will \"hit\" the earlier layer weights and embed unwanted randomness into it. And for that reason, it might make sense to freeze the earlier layer weights so that we don't override the valuable general features that we learned earlier. \n\n<p align='center'>\n    <img alt=\"picture 2\" src=\"https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/7de59870c07d7bb724dac3f57c9077dc486cd6ad0ad957f5bcf61e505719b34e.png\" width=\"300\" />  \n</p>\n\n\nQuestion: what is the difference between the above paradigm and self-supervised pre-training (e.g., using things like DINO and things like image puzzle occlusion)? \n\nQuestion: do you need labels to pre-train for a target task that is supervised? \n\n\n### Where might the common wisdom break?  \n\n(Note: by common wisdom, we mean the things generally people do when TL'ing: e.g., freeze all layers but last, need diverse source dataset, etc.) \n\nHere are some recent results: \n\n- From the paper: \"Unsupervised pre-training objectives may not require diverse data for pre-training.\" \n  - Result was that you don't actually need a diverse data set for pre-training (breaks common wisdom). \n- Yoonho‚Äôs (TA) recent experiment \n  - We know that fine-tuning works well for only last layer. But why? last layer is really just like any other layer. \n  - Maybe for low-level distribution shifts, it might actually be better to only train a first layer and freeze the rest. \n  - Result: Fine-tuning the first or middle layers can work better than the last layers. \n  - Paper was released just last week! (Lee*, Chen*, Tajwar, Kumar, Yao, Liang, Finn. Surgical Fine-Tuning Improves Adaptation to Distribution Shifts. Openreview 09/28/22.). \n\nOk... wow lots of design choices then. Despite this, Chelsea recommends: \n\n- Train last layer then fine-tune entire network \n\n<p align='center'>\n    <img alt=\"picture 3\" src=\"https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/c0edd64e1773724db7c60f580f6e260f806ed00ca7d0c938cc67b147a6d88eb4.png\" width=\"300\" />  \n</p>\n\n- And the idea is that we don't mess up the earlier learned features by init the last layer to be within scope of the previous ones first before actually fine-tuning. \n\n> Major problem: Fine-tuning doesn‚Äôt work well with very small target task datasets. This is where meta-learning can help.\n\n## Meta-learning\n\nWe will cover: \n- Problem formulation\n- General recipe of meta-learning algorithms\n\nTwo views: mechanistic and probabilisitc. \n\n### Probabilistic ML \n\n- Bayesian networks review: many random variables as nodes in a direct graph. $P(y | x)$ (distribution) means $y$ is dependent on $x$ (not vise versa). \n- Let's now draw the graphical model for classic single-task learning. \n  \n<p align='center'>\n    <img alt=\"picture 4\" src=\"https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/435375bb51bb210cb487820da262abfcb2226faf6cf25284489e979754d329f4.png\" width=\"200\" />  \n</p>\n\n- Now multi-task learning: \n\n### Mechanistic view \n\n... "},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"3.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.251","theme":"cosmo","categories":["lecture"]},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"3.pdf"},"language":{},"metadata":{"block-headings":true,"categories":["lecture"]},"extensions":{"book":{}}},"docx":{"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"docx","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"page-width":6.5},"pandoc":{"default-image-extension":"png","to":"docx","output-file":"3.docx"},"language":{},"metadata":{"categories":["lecture"]},"extensions":{"book":{}}}}}