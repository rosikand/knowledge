<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Knowledge – quarto-input81f06158</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Knowledge</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">Home</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes.html">Stanford Notes</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../machine-learning.html">Machine Learning</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../concepts.html">Concepts</a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="week-3-lecture-1---search-i" class="level1">
<h1>Week 3, Lecture 1 - Search I</h1>
<p><code>Date: 10/10/22</code></p>
<section id="i.-overview" class="level2">
<h2 class="anchored" data-anchor-id="i.-overview">I. Overview</h2>
<p>We now move into the next unit of the course: <strong>Search</strong>. This is a reflex-based paradigm. We will still abide by the principles of the “model, learning, and inference” paradigm. To introduce search, take the following canonical problem:</p>
<div id="exm-default" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 </strong></span>(<strong>Route planning</strong>) Given as the input a map, a source point and a destination point, output a sequence of actions (e.g., go straight, turn left, or turn right) that will take us from the source to the destination. Evaluate based on custom objective (e.g., most scenic route, shortest path, etc.)</p>
</div>
<ul>
<li>There are many more examples that we can think of. Robot motion planning,solving puzzles, etc. Many traditional (non-ML) algorithmic paradigms (e.g., dynamic programming) make its way into AI through this medium. The main idea though, is that:
<ul>
<li>Search problems are defined by their <strong>objective</strong> and the <strong>actions</strong> it can take to get there.</li>
</ul></li>
</ul>
<section id="beyond-reflex" class="level4">
<h4 class="anchored" data-anchor-id="beyond-reflex">Beyond reflex</h4>
<p align="center">
<img alt="picture 1" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/d927b01d4eb23e8f998111ea391c7df53b93c78cac3067fb65829aabaa6b0ed9.png" width="500">
</p>
<ul>
<li>Reflex models are very high-level: e.g., classifiers which output a quick “yes” or “no”. Not dependent on any future/past predictions.</li>
<li>However, some applications of AI (such as solving puzzles), demand more.</li>
<li><strong>Search problems</strong> are an instance of <strong>state-based models</strong>.</li>
<li>We are still building a predictor <span class="math inline">\(f\)</span> which takes an input <span class="math inline">\(x\)</span>, but will now return an entire <strong>action sequence</strong>, not just a single action (i.e., a “reflex”).</li>
<li>You can think of the difference as defined by the task. Solving a puzzle is not the same as classifying cats vs.&nbsp;monkeys.</li>
<li>Can’t you solve a search problem just by iteratively multiplying the reflex-based predictions to get an action sequence?
<ul>
<li>Not really… future actions should be conditioned on past actions!</li>
<li>But… think of this: “if you’re walking around Stanford for the first time, you might have to really plan things out, but eventually it kind of becomes reflex.”.</li>
</ul></li>
<li>We have looked at many real-world examples of this new “search” paradigm. For each example, <strong>the key is to decompose the output solution into a sequence of primitive actions</strong>. In addition, we need to think about <strong>how to evaluate different possible outputs</strong>.</li>
</ul>
</section>
<section id="roadmap" class="level4">
<h4 class="anchored" data-anchor-id="roadmap">Roadmap</h4>
<ul>
<li>In the ML unit, we had the <strong>“model, learning, and inference” paradigm</strong>. We adapt this for search too.
<ul>
<li><strong>Machine learning</strong>:
<ul>
<li><strong>Modeling</strong>: feature extractor + neural architecture</li>
<li><strong>Inference</strong>: model forward pass (<span class="math inline">\(f(x)\)</span>)</li>
<li><strong>Learning</strong>: algorithms such as stochastic gradient descent to find optimal model weights</li>
</ul></li>
<li><strong>Search</strong>: find out down below! We will start with modeling and inference, then learning next lecture.</li>
</ul></li>
</ul>
<p>Here is a roadmap of what we will cover:</p>
<p align="center">
<img alt="picture 2" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/e0cf1e0851f3e28aeb23c7c6c58d0daa93a1f9f989f77e63f0c108bcd29692f9.png" width="500">
</p>
<blockquote class="blockquote">
<p>The main idea is to cover how we define (“model”) search problems, and come up with <strong>algorithms to solve them</strong>.</p>
</blockquote>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>(<strong>State-based vs reflex-models</strong>) The main TL;DR is to understand the following difference and what problems we can now solve with this new tool:</p>
<p><strong>Reflex-based modeling</strong>:</p>
<p><span class="math display">\[
x \rightarrow f \rightarrow \text { single action } y \in\{-1,+1\}
\]</span></p>
<p><strong>(Search) State-based modeling</strong>:</p>
<p><span class="math display">\[
x \rightarrow f \rightarrow \text { action sequence }\left(a_1, a_2, a_3, a_4, \ldots\right)
\]</span></p>
<p>This allows us to not only solve things like classification problems with reflex-based modeling, but also now solve things like route planning with state-based modeling.</p>
</div>
</div>
</section>
</section>
<section id="ii.-modeling" class="level2">
<h2 class="anchored" data-anchor-id="ii.-modeling">II. Modeling</h2>
<p>Ok… cool! We now have a general intuition for what is search/state-based modeling. Let’s get formal now with definitions.</p>
<p>We will introduce modeling via the following example.</p>
<div class="callout-note callout callout-style-simple">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<div id="exm-default" class="theorem example">
<p><span class="theorem-title"><strong>Example 2 </strong></span>(<strong>Farmer search problems</strong>) A farmer wants to get his cabbage, goat, and wolf across a river. He has a boat that only holds two. He cannot leave the cabbage and goat alone or the goat and wolf alone. How many river crossings does he need?</p>
</div>
</div>
</div>
</div>
<ul>
<li>You probably thought of each scenario playing out in your head. How can we build a system to do this automatically.</li>
<li>Search <strong>problems define the possibilities</strong>, and search <strong>algorithms explore these possibilities</strong>.</li>
<li>For this problem, we have eight possible actions, which will be denoted by a concise set of symbols.</li>
</ul>
<p align="center">
<img alt="picture 4" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/a8fcf66fd4dbf46005eecfc64fbbc6728de1852feb7638e41c3e5c6b7a1e7ac8.png" width="300">
</p>
<ul>
<li>We can start to build a <strong>search tree</strong> of each “what-if” scenario. Playing out each scenario, we get the following:</li>
</ul>
<p align="center">
<img alt="picture 5" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/e3c33ead58c5b6dab9fe89e299c9c05dd44700bd9b7e21af600ac2bb3584f259.png" width="500">
</p>
<ul>
<li><strong>Each scenario is represented by a “branch”</strong> of the search tree.</li>
<li>We terminate the branch (leaf) once we reached a final state (win or lose).</li>
</ul>
<p>Let’s formalize this.</p>
<section id="defining-the-search-problem" class="level3">
<h3 class="anchored" data-anchor-id="defining-the-search-problem">Defining the search problem</h3>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="def-default" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 </strong></span><strong>(Search Problem)</strong> A search problem is built upon the following:</p>
<ul>
<li><span class="math inline">\(s_{\text {start }}\)</span> : starting state</li>
<li>Actions <span class="math inline">\((s)\)</span> : possible actions</li>
<li><span class="math inline">\(\operatorname{Cost}(s, a)\)</span> : action cost</li>
<li><span class="math inline">\(\operatorname{Succ}(s, a)\)</span> : successor</li>
<li>IsEnd <span class="math inline">\((s)\)</span> : reached end state?</li>
</ul>
</div>
</div>
</div>
<p>This can be visually represented/solved with a search tree. The root of the tree is the <strong>start state</strong> <span class="math inline">\(s_{\text {start }}\)</span>, and the leaves are the <strong>end states</strong> (IsEnd <span class="math inline">\((s)\)</span> is true). Each edge leaving a node <span class="math inline">\(s\)</span> corresponds to a possible action <span class="math inline">\(a \in \operatorname{Actions}(s)\)</span> that could be performed in state <span class="math inline">\(s\)</span>. The edge is labeled with the action and its cost, written <span class="math inline">\(a: \operatorname{Cost}(s, a)\)</span>. The action leads deterministically to the successor state <span class="math inline">\(\operatorname{Succ}(s, a)\)</span>, represented by the child node.</p>
<p>In the example, each root-to-leaf path represents a possible action sequence, and the sum of the costs of the edges is the cost of that path. The goal is to find the root-to-leaf path that ends in a valid end state with minimum cost.</p>
</section>
</section>
<section id="iii.-tree-search" class="level2">
<h2 class="anchored" data-anchor-id="iii.-tree-search">III. Tree search</h2>
<p>Cool… we got the formalism and modeling down. Now let’s build algorithms to solve them! We will discuss several tree-based algorithms here.</p>
<p><strong>The idea</strong>:</p>
<p align="center">
<img alt="picture 6" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/840f2201d46e7a7f8ee5a4281a7eb6e4efb87556b3d54973f8cedec107121806.png" width="300">
</p>
<ul>
<li>We have some <strong>tree</strong> (model) representing the <strong>search problem</strong>. We want to find paths that lead to successful leaves with the minimum-cost. There are several algorithms that can do this. We can keep track of them via the following factors:
<ul>
<li>Algorithm name</li>
<li>Cost</li>
<li>Time</li>
<li>Space</li>
</ul></li>
</ul>
<section id="backtracking" class="level3">
<h3 class="anchored" data-anchor-id="backtracking">Backtracking</h3>
<ul>
<li>106B!</li>
<li>Brute forces all paths. Basically, just complete <a href="https://stackoverflow.com/questions/687731/breadth-first-vs-depth-first">depth-first traversal</a> of the search tree and update minimum-cost path along the way.</li>
<li>We consider all possible actions <span class="math inline">\(a\)</span> (edges) from state <span class="math inline">\(s\)</span> (node), and recursively search each of the possibilities, updating the minimum-cost and path along the way.</li>
<li>To get an idea of complexity, we define the following:
<ul>
<li><strong>branching factor</strong> <span class="math inline">\(b\)</span>: number of available actions at each state<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</li>
<li><strong>maximum depth</strong> <span class="math inline">\(D\)</span>: each path consists of <span class="math inline">\(D\)</span> or less actions/edges.</li>
</ul></li>
<li><strong>Complexity</strong>:
<ul>
<li><strong>Space</strong>: <span class="math inline">\(O(D)\)</span></li>
<li><strong>Time</strong>: <span class="math inline">\(O\left(b^D\right)\)</span></li>
</ul></li>
<li>Why <span class="math inline">\(O(D)\)</span> for space?
<ul>
<li>Each path is defined by the sequence of actions you take at each node in the branch. This can be, at the worst, <span class="math inline">\(D\)</span> long. Example:
<p align="center">
<img alt="picture 8" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/4b93fcef8293f4e07055ea28da74515fb119b0a5f4b06d42390b35b23de4111e.png" width="200">
</p></li>
</ul></li>
<li>Time also makes sense. We need to search, at worst, <span class="math inline">\(D\)</span> things for each total branch. But the branching factor <span class="math inline">\(b\)</span> (a scaling factor), exponentially grows this.</li>
</ul>
<p>Algorithm:</p>
<p align="center">
<img alt="picture 7" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/be8a914ff8fd7fe53cb9c47e0af34444864693f66a14c3485a4eeb467601f070.png" width="450">
</p>
</section>
<section id="depth-first-search" class="level3">
<h3 class="anchored" data-anchor-id="depth-first-search">Depth-first search</h3>
<p>Before we go on, let’s do a quick recap:</p>
<ul>
<li>State-based modeling allows us to model and solve problems where the output is a sequence of actions to take between states.</li>
<li>We formalized a search problem via notations such as states and actions.</li>
<li>We can model a search problem via a tree.</li>
<li>We can solve a search problem via a traversal algorithm.</li>
<li>There exists several such algorithms, each differing in performance slightly (some suited for tasks better than others).</li>
</ul>
<p>Onto DFS:</p>
<ul>
<li>Ok… suppose we don’t care about finding the <em>minimum</em>-cost path, but rather simply the first solution path. That is, make the cost <span class="math inline">\(c = 0\)</span>.</li>
<li>Then, DFS works the best here. Just traverse each branch in a depth-fashion. Stop when you reach the first leaf.</li>
<li>Time and space complexity is still the same, because, in the worst case, we traverse the whole tree and don’t end up with a solution.</li>
</ul>
</section>
<section id="breadth-first-search" class="level3">
<h3 class="anchored" data-anchor-id="breadth-first-search">Breadth-first search</h3>
<ul>
<li>Now suppose all costs of each action are constant. Every action costs <span class="math inline">\(c\)</span>.</li>
<li>Then, do BFS.</li>
<li>We traverse the tree laterally.</li>
<li>When we reach a solution, we know we are at the best one.
<ul>
<li>Think about it. If we traverse from the left to the right and find a successful leaf node (successful end state), there can be no branch that is shorter in depth.</li>
</ul></li>
</ul>
<p align="center">
<img alt="picture 9" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/0741e8715aecd4f01f36474ef42fb7ba958bacc80b5aeaf9ae768a534902f3ad.png" width="490">
</p>
</section>
</section>
<section id="iv.-dynamic-programming" class="level2">
<h2 class="anchored" data-anchor-id="iv.-dynamic-programming">IV. Dynamic Programming</h2>
<ul>
<li>Time-complexity was pretty bad for the tree traversal algorithms for solving search problems. Lots of it is simply too brute-force to be reasonable (at worst case).</li>
<li>Time-complexity was <strong>growing exponentially</strong> because we’d have to recurse through the whole maze.</li>
<li>Let’s see how DP can speed this up.</li>
</ul>
<p>Here is the general idea:</p>
<div id="exm-default" class="theorem example">
<span class="theorem-title"><strong>Example 3 </strong></span>take the following graph:<br>

<p align="center">
<img alt="picture 11" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/ef9b19a1dc4cac31d0c2e3f2a560b28824b0b25b2aa3f48cc8aa5c0d300100fd.png" width="700">
</p>
<p>in tree search (take backtracking), we’d have to recurse through each branch, for every branch. Exponential time complexity! However, notice that, for example, once we hit a <span class="math inline">\(5\)</span>, the rest of the branch is the same. This is the key idea. We can store the subproblem path of starting from <span class="math inline">\(5\)</span> to the solution (leaf) in a lookup table and next time we are at a <span class="math inline">\(5\)</span>, we just look it up! We save tons of time but sacrifice a bit of space while were at it (which is ok!). This concept is called <strong>memoization</strong>.</p>
</div>
<p>This slide formalizes the concept of dynamic programming.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="def-default" class="theorem definition">
<span class="theorem-title"><strong>Definition 2 </strong></span>(<strong>Dynamic programming</strong>)
<p align="center">
<img alt="picture 12" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/338c7106f8492df7ebaf341d0f3b6f9796e3209c785d8894c8bd5fd1fdba689b.png" width="600">
</p>
</div>
</div>
</div>
<p>In code, this would be something like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> table[subproblem_solution] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> table[subproblem_solution]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># recurse as usual </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># base case </span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    solution <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> isEnd(state):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        solution <span class="op">=</span> ... </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># recursive step </span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> action <span class="kw">in</span> actions:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        ... </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        solution <span class="op">=</span> ...</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    table[subproblem_solution] <span class="op">=</span> solution </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> solution </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Key observation is that the <strong>future costs only depend on current city… not on what we did in the past to get to that city</strong>.
<ul>
<li>What we really mean is that future cost only depends on state.</li>
<li>State goes from “past sequence of actions (e.g.: 1 –&gt; 2 –&gt; 5 –&gt; 6) to just the current thing (e.g.: 6).</li>
<li>Exponential to polynomial time (based on number of states in polynomial time (<span class="math inline">\(O(n)\)</span>)).</li>
</ul></li>
</ul>
<p>Idea of “state”:</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="def-default" class="theorem definition">
<span class="theorem-title"><strong>Definition 3 </strong></span>(<strong>State</strong>) A state is a summary of all the past actions sufficient to choose future actions optimally. e.g.,:
<p align="center">
<img alt="picture 15" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/c737889b0d69032d1077bceb63dd6c13317a3a898aa03e68c2e9b7339e8c39eb.png" width="200">
</p>
</div>
</div>
</div>
<section id="adding-a-constraint" class="level3">
<h3 class="anchored" data-anchor-id="adding-a-constraint">Adding a constraint</h3>
<p>Cool… but what happens if we add a constraint dependent on the state.</p>
<div class="callout-note callout callout-style-simple">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<div id="exm-default" class="theorem example">
<p><span class="theorem-title"><strong>Example 4 </strong></span>(<strong>Route finding</strong>) Find the minimum cost path from city 1 to city <span class="math inline">\(n\)</span>, only moving forward. It costs <span class="math inline">\(c_{i j}\)</span> to go from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.</p>
<p>Constraint: Can’t visit three odd cities in a row.</p>
</div>
</div>
</div>
</div>
<ul>
<li>Note that we choose what the “state” is in these DP problems. However, time and space complexity is dependent on the size of the state. So choose wisely. A bit of a balance.
<ul>
<li>This is why the definition of what “state” is from above makes sense: <strong>get the minimal amount of information that you need to know that is sufficient enough to choose actions optimally</strong>.</li>
</ul></li>
</ul>
<p>With this constraint in mind, we can now define a new state definition for this problem.</p>
<p><span class="math display">\[
\text{state = (previous city, current city)}
\]</span></p>
<p>example in this context then:</p>
<p><span class="math display">\[S_0:(n / a, 1)\]</span> <span class="math display">\[S_1:(1,3)\]</span> <span class="math display">\[S_2:(3,7)\]</span></p>
<p>State space (complexity) is then <span class="math inline">\(|S|=N \times N=N^2\)</span>. We can do better. Define state as:</p>
<p><span class="math display">\[
\text{state = (if previous city was odd, current city)}
\]</span></p>
<p>this gives us <span class="math inline">\(|S| = 2n\)</span>.</p>
<p>The whole example here is to drill in the idea of a “state” and how dynamic it can really be defined (but also how important it is to define a good state).</p>
<section id="acyclic-assumption" class="level4">
<h4 class="anchored" data-anchor-id="acyclic-assumption">Acyclic assumption</h4>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="def-default" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4 </strong></span>(<strong>Acyclic assumption</strong>) The state graph defined by <span class="math inline">\(\operatorname{Actions}(s)\)</span> and <span class="math inline">\(\operatorname{Succ}(s, a)\)</span> is acyclic.</p>
</div>
</div>
</div>
<p>Here is a quick primer on the relevant graph algorithm background.</p>
<ul>
<li><strong>Cycle</strong>: a path that starts from a given vertex and ends at the same vertex is called a cycle (<a href="https://www.baeldung.com/cs/cycles-undirected-graph">ref</a>)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</li>
</ul>
<ul>
<li>Acyclic vs.&nbsp;cyclic:</li>
</ul>
<p align="center">
<img alt="picture 16" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/c4aebfc4919edcb62e8a5ef959c5d8d9498d1a10f1474939b9364baeeac13035.png" width="300">
</p>
<ul>
<li>That is, we need an ordering of the states such that we can’t go “back to a state” to acheive the optimal path.</li>
<li>So basically, our state graph just has to be acyclic.</li>
<li>Uniform cost search resolves this.</li>
</ul>
</section>
</section>
<section id="tldr" class="level3">
<h3 class="anchored" data-anchor-id="tldr">TL;DR</h3>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>DP: backtracking + memoization</li>
<li>Memoization: cache all solutions to each subproblem. Next time you encounter subproblem, lookup solution in cache instead of redoing the recursion.</li>
<li>DP offers speed-up in time complexity: exponential to polynomial.</li>
<li>State: how you define your state plays a huge role in performance. Get the minimal amount of information that you need to know that is sufficient enough to choose actions optimally in the future.</li>
<li>However, DP depends on the assumption that the graph being traversed is acyclic. That is, there exists some sequential ordering in the problem (no going backwards!).</li>
<li>Uniform cost search addresses this issue.</li>
</ul>
</div>
</div>
</section>
</section>
<section id="v.-uniform-cost-search" class="level2">
<h2 class="anchored" data-anchor-id="v.-uniform-cost-search">V. Uniform cost search</h2>
<ul>
<li>DP is great, but what happens if we have cycles in our state graph?</li>
<li>UCS is essentially DP but allows for cycles.<br>
</li>
<li>Basically Dijkstra’s algorithm.</li>
<li>Again, we will use the following shortest-path example.</li>
</ul>
<div class="callout-note callout callout-style-simple">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<div id="exm-default" class="theorem example">
<p><span class="theorem-title"><strong>Example 5 </strong></span>(<strong>Route finding</strong>) Find the minimum cost path from city 1 to city <span class="math inline">\(n\)</span>, only moving forward. It costs <span class="math inline">\(c_{i j}\)</span> to go from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.</p>
</div>
</div>
</div>
</div>
<ul>
<li><strong>Motivation</strong>:
<ul>
<li>In DP, we had no cycles, so every future cost only depended on what happens in the future… there is some ordering of the nodes which prevents us from looping backwards to potentially find a more optimal path. The insight is that, once we are at some state <span class="math inline">\(s\)</span>, we know that we got there via the most optimal route from the start state <span class="math inline">\(s_{start}\)</span>. Thus, we only need to consider future costs. Take this visual:
<p align="center">
<img alt="picture 17" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/af1afcd283d1476204185e6fba7eb2a88a0e11874cfe7051ff4331c3d596ee7b.png" width="300">
</p>
We know that at state <span class="math inline">\(s\)</span>, <span class="math inline">\(\operatorname{PastCost}(s)\)</span> is optimal; so we can just focus on computing the minimum futuyre cost, <span class="math inline">\(\operatorname{Cost}(s, a)\)</span>. With cycles, this isn’t always the case.</li>
<li>However, some graphs may have cycles. This introduces the “<strong>going backwards</strong> possibility to find a potentially more optimal path… and thus complicating the problem.</li>
<li>Mathematically, also, the difference is that with DP, we computed future costs, but here we can define the compliment: compute <span class="math inline">\(\operatorname{PastCost}(s)\)</span>: the cost of the minimum cost path from the start state to <span class="math inline">\(s\)</span>. Then, we do DP in reverse going from <span class="math inline">\(s\)</span> to the start state to get the minimum. But again, to use DP, we must ensure that the nodes are computed in order (just reverse this time). But the general idea for USC is to use this “reverse” technique.<br>
</li>
<li>How to solve this? Let’s see what UCS has to offer!</li>
</ul></li>
</ul>
<p><strong>High-level idea</strong>:</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>(<strong>Key idea of UCS:</strong>) UCS enumerates states in order of increasing past cost.</p>
</div>
</div>
<p>Note that we also assume that all actions (edges) are non-negative (<span class="math inline">\(\operatorname{Cost}(s, a) \geq 0\)</span>). Bellman-ford resolves this though.</p>
<ul>
<li>Quick <strong>aside</strong>: UCS and Dijkstra’s are practically equivalent algorithmically, but some differences include:
<ul>
<li>UCS takes as input a search problem, which implicitly defines a large and even infinite graph. Dijkstra’s takes as input a fully discrete and concrete graph.</li>
<li>Output difference: Dijkstra’s outputs shortest path between start state and every other node. UCS only does from one desired state to another. <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></li>
</ul></li>
</ul>
<p>Ok… to describe the algorithm, I recommend just watching the video. However, here is some text from the slides.</p>
<blockquote class="blockquote">
<ul>
<li>The general strategy of UCS is to maintain three sets of nodes: explored, frontier, and unexplored. Throughout the course of the algorithm, we will move states from unexplored to frontier, and from frontier to explored.</li>
<li>The key invariant is that we have computed the minimum cost paths to all the nodes in the explored set. So when the end state moves into the explored set, then we are done.</li>
</ul>
</blockquote>
<p align="center">
<img alt="picture 18" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/47ef0fe0fc3f5057f16cbadc4c0d36f371ec95c1ff2a68bbe351d9ce22a2988c.png" width="500">
</p>
<p>Also, as another aside before we move on, realize that these algorithms take in <strong>state graphs</strong> (not trees). <a href="https://www.youtube.com/watch?v=dRMvK76xQJI">Here</a> is a good video walking through an example of this algorithm in a different light.</p>
<p>Notes:</p>
<ul>
<li>Once the end state is in explored, we terminate the search.</li>
<li><strong>Question</strong>: can we ever update the minimum cost path to some node already in explored? Or is it true that once a state is in explored, it is already at the minimum cost?
<ul>
<li>Ok… the answer is yes (“The key invariant is that we have computed the minimum cost paths to all the nodes in the explored set. So when the end state moves into the explored set, then we are done.”), but I fail to understand why. (update: see below as this is exactly what’s covered next.)</li>
</ul></li>
</ul>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="def-default" class="theorem definition">
<span class="theorem-title"><strong>Definition 5 </strong></span><strong>(Uniform cost search algorithm)</strong>:
<p align="center">
<img alt="picture 19" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/48b14619aa7228821b6d2ef7cd2311951869efaf0c9c4a2b5a42f97d215c4277.png" width="500">
</p>
</div>
</div>
</div>
<ul>
<li><p>So basically, in Dijkstra’s we do the full graph (end when all nodes are in the graph). In UCS, terminate when the end state is moved to explored.</p></li>
<li><p>Ok… I had the following question:</p>
<ul>
<li>Is it possible to add a node beyond the desired end state to the frontier and pop that one off to the explored list first? The answer is yes. It is a great exercise to run UCS on the following graph.</li>
</ul></li>
</ul>
<div class="callout-note callout callout-style-simple">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<div id="exr-default" class="theorem exercise">
<span class="theorem-title"><strong>Exercise 1 </strong></span>(<strong>UCS</strong>) Run uniform cost search on the following graph by finding the minimum cost for <span class="math inline">\(A \rightarrow C\)</span>.
<p align="center">
<img alt="picture 20" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/5e9c11908ba66a2270a46e6d632d0db4cfe7b9cf1039695cc969a00f86052d94.png" width="300">
</p>
<p>Answer: 3 (<span class="math inline">\(A \rightarrow B \rightarrow D \rightarrow C\)</span>).</p>
</div>
</div>
</div>
</div>
<section id="correctness" class="level3">
<h3 class="anchored" data-anchor-id="correctness">Correctness</h3>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="thm-default" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 </strong></span>(<strong>Correctness of UCS</strong>): When a state <span class="math inline">\(s\)</span> is popped from the frontier and moved to explored, its priority is <span class="math inline">\(PastCost(s)\)</span>, the minimum cost to <span class="math inline">\(s\)</span>. That is, once the state <span class="math inline">\(s\)</span> is in explored, the cost is indeed the minimum.</p>
</div>
</div>
</div>
<p>For the proof, watch the video.</p>
<p>Interesting note: - We know that UCS cannot handle negatively-weighted edges. What happens if we just add some arbitrarly large constant to all edges to make them positive and then solve this. Will this work? - NO! See <a href="https://math.stackexchange.com/questions/1021517/increase-by-one-shortest-path-changes-the-edges-or-not">here</a>. It penalizes longer paths more than shorter paths, so we would end up solving a different problem. Paths with more num edges are penalized more than less edges but more weight. If the original path was many small weight edges, but there also exists a large edge(s), the add constant scenario would penalize the many small weights much more and thus the minimum path can change.</p>
<section id="dp-vs.-ucs" class="level4">
<h4 class="anchored" data-anchor-id="dp-vs.-ucs">DP vs.&nbsp;UCS</h4>
<p align="center">
<img alt="picture 21" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/e6ed3993743407f586eb4969047057b3ec1628e48dbea012364e8bd756c5a9f3.png" width="450">
</p>
<div class="callout-note callout callout-style-simple">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<ul>
<li>DP can handle negative costs, UCS cannot.</li>
<li>Because of the above, DP has to explore all <span class="math inline">\(N\)</span> reachable states from the start state (inefficient). However, UCS can avoid this since their are no negative costs.
<ul>
<li>On the contrary, UCS only needs to explore <span class="math inline">\(n\)</span> states where <span class="math inline">\(n\)</span> is the number of states such that each of these states are cheaper to get to than the end state.</li>
</ul></li>
<li>UCS can handle cycles. DP cannot.</li>
<li>UCS has some additional overhead with handling the priority queue, in lookup time.</li>
</ul>
</div>
</div>
</div>
<p><strong>Summary thus far</strong>:</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<strong>Summary (ref: 221 slides)</strong>:
<p align="center">
<img alt="picture 22" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/7ec2a24fd9f4cb8915c934e18f51f01980c464c4600a49e0230553c505593dc2.png" width="500">
</p>
<ul>
<li>We started out with the idea of a search problem, an abstraction that provides a clean interface between modeling and algorithms.</li>
<li>Tree search algorithms are the simplest: just try exploring all possible states and actions. With backtracking search and DFS with iterative deepening, we can scale up to huge state spaces since the memory usage only depends on the number of actions in the solution path. Of course, these algorithms necessarily take exponential time in the worst case.</li>
<li>To do better, we need to think more about bookkeeping. The most important concept from this lecture is the idea of a state, which contains all the information about the past to act optimally in the future. We saw several examples of traveling between cities under various constraints, where coming up with the proper minimal state required a deep understanding of search.</li>
<li>With an appropriately defined state, we can apply either dynamic programming or UCS, which have complementary strengths. The former handles negative action costs and the latter handles cycles. Both require space proportional to the number of states, so we need to make sure that we did a good job with the modeling of the state.</li>
</ul>
</div>
</div>
</div>
<p>A-star is next. But this algorithm is the same as UCS, except we calculate the cost differently. We use a heuristic to guide us towards the end goal better. A hueristic is just some function <span class="math inline">\(f(x)\)</span> where <span class="math inline">\(x\)</span> is a given state.</p>


</section>
</section>
</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>can’t this vary though depending on the depth that we are at?<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://www.baeldung.com/cs/cycles-undirected-graph">this</a> site actually has some good info.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>note that this is an important thing to understand as it gives rise to the motivation for <span class="math inline">\(A^*\)</span>. In UCS, we <em>uniformly</em> align the nodes in order. However, as we will see, <span class="math inline">\(A^*\)</span> has a bias knowing the end goal.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>