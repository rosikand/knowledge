<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Knowledge – quarto-inputd76e3f26</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Knowledge</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">Home</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes.html">Stanford Notes</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../machine-learning.html">Machine Learning</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../concepts.html">Concepts</a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="week-3-lecture-1---search-i" class="level1">
<h1>Week 3, Lecture 1 - Search I</h1>
<p><code>Date: 10/10/22</code></p>
<section id="i.-overview" class="level2">
<h2 class="anchored" data-anchor-id="i.-overview">I. Overview</h2>
<p>We now move into the next unit of the course: <strong>Search</strong>. This is a reflex-based paradigm. We will still abide by the principles of the “model, learning, and inference” paradigm. To introduce search, take the following canonical problem:</p>
<div id="exm-default" class="theorem example">
<p><span class="theorem-title"><strong>Example 1 </strong></span>(<strong>Route planning</strong>) Given as the input a map, a source point and a destination point, output a sequence of actions (e.g., go straight, turn left, or turn right) that will take us from the source to the destination. Evaluate based on custom objective (e.g., most scenic route, shortest path, etc.)</p>
</div>
<ul>
<li>There are many more examples that we can think of. Robot motion planning,solving puzzles, etc. Many traditional (non-ML) algorithmic paradigms (e.g., dynamic programming) make its way into AI through this medium. The main idea though, is that:
<ul>
<li>Search problems are defined by their <strong>objective</strong> and the <strong>actions</strong> it can take to get there.</li>
</ul></li>
</ul>
<section id="beyond-reflex" class="level4">
<h4 class="anchored" data-anchor-id="beyond-reflex">Beyond reflex</h4>
<p align="center">
<img alt="picture 1" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/d927b01d4eb23e8f998111ea391c7df53b93c78cac3067fb65829aabaa6b0ed9.png" width="500">
</p>
<ul>
<li>Reflex models are very high-level: e.g., classifiers which output a quick “yes” or “no”. Not dependent on any future/past predictions.</li>
<li>However, some applications of AI (such as solving puzzles), demand more.</li>
<li><strong>Search problems</strong> are an instance of <strong>state-based models</strong>.</li>
<li>We are still building a predictor <span class="math inline">\(f\)</span> which takes an input <span class="math inline">\(x\)</span>, but will now return an entire <strong>action sequence</strong>, not just a single action (i.e., a “reflex”).</li>
<li>You can think of the difference as defined by the task. Solving a puzzle is not the same as classifying cats vs.&nbsp;monkeys.</li>
<li>Can’t you solve a search problem just by iteratively multiplying the reflex-based predictions to get an action sequence?
<ul>
<li>Not really… future actions should be conditioned on past actions!</li>
<li>But… think of this: “if you’re walking around Stanford for the first time, you might have to really plan things out, but eventually it kind of becomes reflex.”.</li>
</ul></li>
<li>We have looked at many real-world examples of this new “search” paradigm. For each example, <strong>the key is to decompose the output solution into a sequence of primitive actions</strong>. In addition, we need to think about <strong>how to evaluate different possible outputs</strong>.</li>
</ul>
</section>
<section id="roadmap" class="level4">
<h4 class="anchored" data-anchor-id="roadmap">Roadmap</h4>
<ul>
<li>In the ML unit, we had the <strong>“model, learning, and inference” paradigm</strong>. We adapt this for search too.
<ul>
<li><strong>Machine learning</strong>:
<ul>
<li><strong>Modeling</strong>: feature extractor + neural architecture</li>
<li><strong>Inference</strong>: model forward pass (<span class="math inline">\(f(x)\)</span>)</li>
<li><strong>Learning</strong>: algorithms such as stochastic gradient descent to find optimal model weights</li>
</ul></li>
<li><strong>Search</strong>: find out down below! We will start with modeling and inference, then learning next lecture.</li>
</ul></li>
</ul>
<p>Here is a roadmap of what we will cover:</p>
<p align="center">
<img alt="picture 2" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/e0cf1e0851f3e28aeb23c7c6c58d0daa93a1f9f989f77e63f0c108bcd29692f9.png" width="500">
</p>
<blockquote class="blockquote">
<p>The main idea is to cover how we define (“model”) search problems, and come up with <strong>algorithms to solve them</strong>.</p>
</blockquote>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>(<strong>State-based vs reflex-models</strong>) The main TL;DR is to understand the following difference and what problems we can now solve with this new tool:</p>
<p><strong>Reflex-based modeling</strong>:</p>
<p><span class="math display">\[
x \rightarrow f \rightarrow \text { single action } y \in\{-1,+1\}
\]</span></p>
<p><strong>(Search) State-based modeling</strong>:</p>
<p><span class="math display">\[
x \rightarrow f \rightarrow \text { action sequence }\left(a_1, a_2, a_3, a_4, \ldots\right)
\]</span></p>
<p>This allows us to not only solve things like classification problems with reflex-based modeling, but also now solve things like route planning with state-based modeling.</p>
</div>
</div>
</section>
</section>
<section id="ii.-modeling" class="level2">
<h2 class="anchored" data-anchor-id="ii.-modeling">II. Modeling</h2>
<p>Ok… cool! We now have a general intuition for what is search/state-based modeling. Let’s get formal now with definitions.</p>
<p>We will introduce modeling via the following example.</p>
<div class="callout-note callout callout-style-simple">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<div id="exm-default" class="theorem example">
<p><span class="theorem-title"><strong>Example 2 </strong></span>(<strong>Farmer search problems</strong>) A farmer wants to get his cabbage, goat, and wolf across a river. He has a boat that only holds two. He cannot leave the cabbage and goat alone or the goat and wolf alone. How many river crossings does he need?</p>
</div>
</div>
</div>
</div>
<ul>
<li>You probably thought of each scenario playing out in your head. How can we build a system to do this automatically.</li>
<li>Search <strong>problems define the possibilities</strong>, and search <strong>algorithms explore these possibilities</strong>.</li>
<li>For this problem, we have eight possible actions, which will be denoted by a concise set of symbols.</li>
</ul>
<p align="center">
<img alt="picture 4" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/a8fcf66fd4dbf46005eecfc64fbbc6728de1852feb7638e41c3e5c6b7a1e7ac8.png" width="300">
</p>
<ul>
<li>We can start to build a <strong>search tree</strong> of each “what-if” scenario. Playing out each scenario, we get the following:</li>
</ul>
<p align="center">
<img alt="picture 5" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/e3c33ead58c5b6dab9fe89e299c9c05dd44700bd9b7e21af600ac2bb3584f259.png" width="500">
</p>
<ul>
<li><strong>Each scenario is represented by a “branch”</strong> of the search tree.</li>
<li>We terminate the branch (leaf) once we reached a final state (win or lose).</li>
</ul>
<p>Let’s formalize this.</p>
<section id="defining-the-search-problem" class="level3">
<h3 class="anchored" data-anchor-id="defining-the-search-problem">Defining the search problem</h3>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="def-default" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 </strong></span><strong>(Search Problem)</strong> A search problem is built upon the following:</p>
<ul>
<li><span class="math inline">\(s_{\text {start }}\)</span> : starting state</li>
<li>Actions <span class="math inline">\((s)\)</span> : possible actions</li>
<li><span class="math inline">\(\operatorname{Cost}(s, a)\)</span> : action cost</li>
<li><span class="math inline">\(\operatorname{Succ}(s, a)\)</span> : successor</li>
<li>IsEnd <span class="math inline">\((s)\)</span> : reached end state?</li>
</ul>
</div>
</div>
</div>
<p>This can be visually represented/solved with a search tree. The root of the tree is the <strong>start state</strong> <span class="math inline">\(s_{\text {start }}\)</span>, and the leaves are the <strong>end states</strong> (IsEnd <span class="math inline">\((s)\)</span> is true). Each edge leaving a node <span class="math inline">\(s\)</span> corresponds to a possible action <span class="math inline">\(a \in \operatorname{Actions}(s)\)</span> that could be performed in state <span class="math inline">\(s\)</span>. The edge is labeled with the action and its cost, written <span class="math inline">\(a: \operatorname{Cost}(s, a)\)</span>. The action leads deterministically to the successor state <span class="math inline">\(\operatorname{Succ}(s, a)\)</span>, represented by the child node.</p>
<p>In the example, each root-to-leaf path represents a possible action sequence, and the sum of the costs of the edges is the cost of that path. The goal is to find the root-to-leaf path that ends in a valid end state with minimum cost.</p>
</section>
</section>
<section id="iii.-tree-search" class="level2">
<h2 class="anchored" data-anchor-id="iii.-tree-search">III. Tree search</h2>
<p>Cool… we got the formalism and modeling down. Now let’s build algorithms to solve them! We will discuss several tree-based algorithms here.</p>
<p><strong>The idea</strong>:</p>
<p align="center">
<img alt="picture 6" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/840f2201d46e7a7f8ee5a4281a7eb6e4efb87556b3d54973f8cedec107121806.png" width="300">
</p>
<ul>
<li>We have some <strong>tree</strong> (model) representing the <strong>search problem</strong>. We want to find paths that lead to successful leaves with the minimum-cost. There are several algorithms that can do this. We can keep track of them via the following factors:
<ul>
<li>Algorithm name</li>
<li>Cost</li>
<li>Time</li>
<li>Space</li>
</ul></li>
</ul>
<section id="backtracking" class="level3">
<h3 class="anchored" data-anchor-id="backtracking">Backtracking</h3>
<ul>
<li>106B!</li>
<li>Brute forces all paths. Basically, just complete <a href="https://stackoverflow.com/questions/687731/breadth-first-vs-depth-first">depth-first traversal</a> of the search tree and update minimum-cost path along the way.</li>
<li>We consider all possible actions <span class="math inline">\(a\)</span> (edges) from state <span class="math inline">\(s\)</span> (node), and recursively search each of the possibilities, updating the minimum-cost and path along the way.</li>
<li>To get an idea of complexity, we define the following:
<ul>
<li><strong>branching factor</strong> <span class="math inline">\(b\)</span>: number of available actions at each state<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</li>
<li><strong>maximum depth</strong> <span class="math inline">\(D\)</span>: each path consists of <span class="math inline">\(D\)</span> or less actions/edges.</li>
</ul></li>
<li><strong>Complexity</strong>:
<ul>
<li><strong>Space</strong>: <span class="math inline">\(O(D)\)</span></li>
<li><strong>Time</strong>: <span class="math inline">\(O\left(b^D\right)\)</span></li>
</ul></li>
<li>Why <span class="math inline">\(O(D)\)</span> for space?
<ul>
<li>Each path is defined by the sequence of actions you take at each node in the branch. This can be, at the worst, <span class="math inline">\(D\)</span> long. Example:
<p align="center">
<img alt="picture 8" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/4b93fcef8293f4e07055ea28da74515fb119b0a5f4b06d42390b35b23de4111e.png" width="200">
</p></li>
</ul></li>
<li>Time also makes sense. We need to search, at worst, <span class="math inline">\(D\)</span> things for each total branch. But the branching factor <span class="math inline">\(b\)</span> (a scaling factor), exponentially grows this.</li>
</ul>
<p>Algorithm:</p>
<p align="center">
<img alt="picture 7" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/be8a914ff8fd7fe53cb9c47e0af34444864693f66a14c3485a4eeb467601f070.png" width="450">
</p>
</section>
<section id="depth-first-search" class="level3">
<h3 class="anchored" data-anchor-id="depth-first-search">Depth-first search</h3>
<p>Before we go on, let’s do a quick recap:</p>
<ul>
<li>State-based modeling allows us to model and solve problems where the output is a sequence of actions to take between states.</li>
<li>We formalized a search problem via notations such as states and actions.</li>
<li>We can model a search problem via a tree.</li>
<li>We can solve a search problem via a traversal algorithm.</li>
<li>There exists several such algorithms, each differing in performance slightly (some suited for tasks better than others).</li>
</ul>
<p>Onto DFS:</p>
<ul>
<li>Ok… suppose we don’t care about finding the <em>minimum</em>-cost path, but rather simply the first solution path. That is, make the cost <span class="math inline">\(c = 0\)</span>.</li>
<li>Then, DFS works the best here. Just traverse each branch in a depth-fashion. Stop when you reach the first leaf.</li>
<li>Time and space complexity is still the same, because, in the worst case, we traverse the whole tree and don’t end up with a solution.</li>
</ul>
</section>
<section id="breadth-first-search" class="level3">
<h3 class="anchored" data-anchor-id="breadth-first-search">Breadth-first search</h3>
<ul>
<li>Now suppose all costs of each action are constant. Every action costs <span class="math inline">\(c\)</span>.</li>
<li>Then, do BFS.</li>
<li>We traverse the tree laterally.</li>
<li>When we reach a solution, we know we are at the best one.
<ul>
<li>Think about it. If we traverse from the left to the right and find a successful leaf node (successful end state), there can be no branch that is shorter in depth.</li>
</ul></li>
</ul>
<p align="center">
<img alt="picture 9" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/0741e8715aecd4f01f36474ef42fb7ba958bacc80b5aeaf9ae768a534902f3ad.png" width="490">
</p>
</section>
</section>
<section id="iv.-dynamic-programming" class="level2">
<h2 class="anchored" data-anchor-id="iv.-dynamic-programming">IV. Dynamic Programming</h2>
<ul>
<li>Time-complexity was pretty bad for the tree traversal algorithms for solving search problems. Lots of it is simply too brute-force to be reasonable (at worst case).</li>
<li>Time-complexity was <strong>growing exponentially</strong> because we’d have to recurse through the whole maze.</li>
<li>Let’s see how DP can speed this up.</li>
</ul>
<p>Here is the general idea:</p>
<div id="exm-default" class="theorem example">
<span class="theorem-title"><strong>Example 3 </strong></span>take the following graph:<br>

<p align="center">
<img alt="picture 11" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/ef9b19a1dc4cac31d0c2e3f2a560b28824b0b25b2aa3f48cc8aa5c0d300100fd.png" width="700">
</p>
<p>in tree search (take backtracking), we’d have to recurse through each branch, for every branch. Exponential time complexity! However, notice that, for example, once we hit a <span class="math inline">\(5\)</span>, the rest of the branch is the same. This is the key idea. We can store the subproblem path of starting from <span class="math inline">\(5\)</span> to the solution (leaf) in a lookup table and next time we are at a <span class="math inline">\(5\)</span>, we just look it up! We save tons of time but sacrifice a bit of space while were at it (which is ok!). This concept is called <strong>memoization</strong>.</p>
</div>
<p>This slide formalizes the concept of dynamic programming.</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="def-default" class="theorem definition">
<span class="theorem-title"><strong>Definition 2 </strong></span>(<strong>Dynamic programming</strong>)
<p align="center">
<img alt="picture 12" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/338c7106f8492df7ebaf341d0f3b6f9796e3209c785d8894c8bd5fd1fdba689b.png" width="600">
</p>
</div>
</div>
</div>
<p>In code, this would be something like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> table[subproblem_solution] <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> table[subproblem_solution]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># recurse as usual </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># base case </span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    solution <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> isEnd(state):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        solution <span class="op">=</span> ... </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># recursive step </span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> action <span class="kw">in</span> actions:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        ... </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        solution <span class="op">=</span> ...</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    table[subproblem_solution] <span class="op">=</span> solution </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> solution </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Key observation is that the <strong>future costs only depend on current city… not on what we did in the past to get to that city</strong>.
<ul>
<li>What we really mean is that future cost only depends on state.</li>
<li>State goes from “past sequence of actions (e.g.: 1 –&gt; 2 –&gt; 5 –&gt; 6) to just the current thing (e.g.: 6).</li>
<li>Exponential to polynomial time (based on number of states in polynomial time (<span class="math inline">\(O(n)\)</span>)).</li>
</ul></li>
</ul>
<p>Idea of “state”:</p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="def-default" class="theorem definition">
<span class="theorem-title"><strong>Definition 3 </strong></span>(<strong>State</strong>) A state is a summary of all the past actions sufficient to choose future actions optimally. e.g.,:
<p align="center">
<img alt="picture 15" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/c737889b0d69032d1077bceb63dd6c13317a3a898aa03e68c2e9b7339e8c39eb.png" width="200">
</p>
</div>
</div>
</div>
<section id="adding-a-constraint" class="level3">
<h3 class="anchored" data-anchor-id="adding-a-constraint">Adding a constraint</h3>
<p>Cool… but what happens if we add a constraint dependent on the state.</p>
<div class="callout-note callout callout-style-simple">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<div id="exm-default" class="theorem example">
<p><span class="theorem-title"><strong>Example 4 </strong></span>(<strong>Route finding</strong>) Find the minimum cost path from city 1 to city <span class="math inline">\(n\)</span>, only moving forward. It costs <span class="math inline">\(c_{i j}\)</span> to go from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.</p>
<p>Constraint: Can’t visit three odd cities in a row.</p>
</div>
</div>
</div>
</div>
<ul>
<li>Note that we choose what the “state” is in these DP problems. However, time and space complexity is dependent on the size of the state. So choose wisely. A bit of a balance.
<ul>
<li>This is why the definition of what “state” is from above makes sense: <strong>get the minimal amount of information that you need to know that is sufficient enough to choose actions optimally</strong>.</li>
</ul></li>
</ul>
<p>With this constraint in mind, we can now define a new state definition for this problem.</p>
<p><span class="math display">\[
\text{state = (previous city, current city)}
\]</span></p>
<p>example in this context then:</p>
<p><span class="math display">\[S_0:(n / a, 1)\]</span> <span class="math display">\[S_1:(1,3)\]</span> <span class="math display">\[S_2:(3,7)\]</span></p>
<p>State space (complexity) is then <span class="math inline">\(|S|=N \times N=N^2\)</span>. We can do better. Define state as:</p>
<p><span class="math display">\[
\text{state = (if previous city was odd, current city)}
\]</span></p>
<p>this gives us <span class="math inline">\(|S| = 2n\)</span>.</p>
<p>The whole example here is to drill in the idea of a “state” and how dynamic it can really be defined (but also how important it is to define a good state).</p>
<section id="acyclic-assumption" class="level4">
<h4 class="anchored" data-anchor-id="acyclic-assumption">Acyclic assumption</h4>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<div id="def-default" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4 </strong></span>(<strong>Acyclic assumption</strong>) The state graph defined by <span class="math inline">\(\operatorname{Actions}(s)\)</span> and <span class="math inline">\(\operatorname{Succ}(s, a)\)</span> is acyclic.</p>
</div>
</div>
</div>
<p>Here is a quick primer on the relevant graph algorithm background.</p>
<ul>
<li><strong>Cycle</strong>: a path that starts from a given vertex and ends at the same vertex is called a cycle (<a href="https://www.baeldung.com/cs/cycles-undirected-graph">ref</a>)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</li>
</ul>
<ul>
<li>Acyclic vs.&nbsp;cyclic:</li>
</ul>
<p align="center">
<img alt="picture 16" src="https://cdn.jsdelivr.net/gh/minimatest/vscode-images/images/c4aebfc4919edcb62e8a5ef959c5d8d9498d1a10f1474939b9364baeeac13035.png" width="300">
</p>
<ul>
<li>That is, we need an ordering of the states such that we can’t go “back to a state” to acheive the optimal path.</li>
<li>So basically, our state graph just has to be acyclic.</li>
<li>Uniform cost search resolves this.</li>
</ul>
</section>
</section>
<section id="tldr" class="level3">
<h3 class="anchored" data-anchor-id="tldr">TL;DR</h3>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>DP: backtracking + memoization</li>
<li>Memoization: cache all solutions to each subproblem. Next time you encounter subproblem, lookup solution in cache instead of redoing the recursion.</li>
<li>DP offers speed-up in time complexity: exponential to polynomial.</li>
<li>State: how you define your state plays a huge role in performance. Get the minimal amount of information that you need to know that is sufficient enough to choose actions optimally in the future.</li>
<li>However, DP depends on the assumption that the graph being traversed is acyclic. That is, there exists some sequential ordering in the problem (no going backwards!).</li>
<li>Uniform cost search addresses this issue.</li>
</ul>
</div>
</div>
</section>
</section>
<section id="v.-uniform-cost-search" class="level2">
<h2 class="anchored" data-anchor-id="v.-uniform-cost-search">V. Uniform cost search</h2>
<p>DP with cycles.</p>
<p>Basically Dijkstra’s algorithm.</p>
<p>Again, we will use the following shortest-path example.</p>
<div class="callout-note callout callout-style-simple">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<div id="exm-default" class="theorem example">
<p><span class="theorem-title"><strong>Example 5 </strong></span>(<strong>Route finding</strong>) Find the minimum cost path from city 1 to city <span class="math inline">\(n\)</span>, only moving forward. It costs <span class="math inline">\(c_{i j}\)</span> to go from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>.</p>
</div>
</div>
</div>
</div>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>can’t this vary though depending on the depth that we are at?<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://www.baeldung.com/cs/cycles-undirected-graph">this</a> site actually has some good info.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>