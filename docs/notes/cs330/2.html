<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Knowledge – quarto-inputb69621ad</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Knowledge</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">Home</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../notes.html">Stanford Notes</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../machine-learning.html">Machine Learning</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../concepts.html">Concepts</a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#week-1-lecture-2---multi-task-learning" id="toc-week-1-lecture-2---multi-task-learning" class="nav-link active" data-scroll-target="#week-1-lecture-2---multi-task-learning">Week 1, Lecture 2 - Multi-task learning</a>
  <ul class="collapse">
  <li><a href="#multi-task-setup" id="toc-multi-task-setup" class="nav-link" data-scroll-target="#multi-task-setup">Multi-task setup</a>
  <ul class="collapse">
  <li><a href="#model" id="toc-model" class="nav-link" data-scroll-target="#model">Model</a></li>
  <li><a href="#loss" id="toc-loss" class="nav-link" data-scroll-target="#loss">Loss</a></li>
  <li><a href="#optimization" id="toc-optimization" class="nav-link" data-scroll-target="#optimization">Optimization</a></li>
  </ul></li>
  <li><a href="#pytorch-example" id="toc-pytorch-example" class="nav-link" data-scroll-target="#pytorch-example">PyTorch Example</a></li>
  <li><a href="#applications" id="toc-applications" class="nav-link" data-scroll-target="#applications">Applications</a></li>
  <li><a href="#confusionsquesions" id="toc-confusionsquesions" class="nav-link" data-scroll-target="#confusionsquesions">Confusions/quesions</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<section id="week-1-lecture-2---multi-task-learning" class="level1">
<h1>Week 1, Lecture 2 - Multi-task learning</h1>
<p>In a traditional supervised ML paradigm, you have a labeled dataset, <span class="math inline">\(\mathscr{D}=\left\{(\mathbf{x}, \mathbf{y})_k\right\}\)</span>, where the goal is to minimize some loss function (<span class="math inline">\(\mathscr{L}\)</span>) given <span class="math inline">\(\mathscr{D}\)</span>, by finding relevant parameters, <span class="math inline">\(\theta\)</span> (i.e., the <strong>task</strong>):</p>
<p><span class="math display">\[
\min _\theta \mathscr{L}(\theta, \mathscr{D}).
\]</span></p>
<section id="multi-task-setup" class="level2">
<h2 class="anchored" data-anchor-id="multi-task-setup">Multi-task setup</h2>
<p>The setup is the same as above, but instead of optimizing one objective, we want to optimize several (under the same model!) at once.</p>
<p><span class="math display">\[
\text { Solve multiple tasks } \mathscr{T}_1, \cdots, \mathscr{T}_T \text { at once. }
\]</span></p>
<p><strong>Example</strong> (<a href="https://pyimagesearch.com/2022/08/17/multi-task-learning-and-hydranets-with-pytorch/">credit</a>):</p>
<p>instead of doing this (as usual):</p>
<p><img width="500" alt="image" src="https://user-images.githubusercontent.com/57341225/190859034-1c1cd295-8acf-4b91-bd5f-b3eaa8e5e17c.png"></p>
<p>we do this:</p>
<p><img width="500" alt="image" src="https://user-images.githubusercontent.com/57341225/190859054-22682478-eefc-4bf4-a8c4-1ec3d6353c2a.png"></p>
<p>Three components:</p>
<ul>
<li>Model</li>
<li>Loss (objective)</li>
<li>Optimization</li>
</ul>
<section id="model" class="level3">
<h3 class="anchored" data-anchor-id="model">Model</h3>
<p>We ask, should we share parameters across tasks? Or should the learnable parameters in the architecture be entirely separate for each task? The latter may look something like this (credit: CS 330 slides):</p>
<p><img width="500" alt="image" src="https://user-images.githubusercontent.com/57341225/190859106-c52f4424-30eb-4c85-97ea-a29143eb9de8.png"></p>
<p>and the former:</p>
<p><img width="500" alt="image" src="https://user-images.githubusercontent.com/57341225/190859130-7ba5a586-65fd-4c2f-a042-44c403c74ba2.png"></p>
<p>See <a href="https://arxiv.org/pdf/2001.06782.pdf">PCGrad</a>.</p>
</section>
<section id="loss" class="level3">
<h3 class="anchored" data-anchor-id="loss">Loss</h3>
<p>To obtain the loss, we perform a simple summation over each of the individual task’s loss:</p>
<p><span class="math display">\[
\min _\theta \sum_{i=1}^T \mathscr{L}_i\left(\theta, \mathscr{D}_i\right)
\]</span></p>
<p>Of course, some tasks might be important than others so we can performed a weighted summation:</p>
<p><span class="math display">\[
\min _\theta \sum_{i=1}^T w_i \mathscr{L}_i\left(\theta, \mathscr{D}_i\right)
\]</span></p>
<p>Note that we can update the weights during training (as a learnable parameter) or manually determime the weights of each loss beforehand (a hyperparameter).</p>
</section>
<section id="optimization" class="level3">
<h3 class="anchored" data-anchor-id="optimization">Optimization</h3>
<p>Optimization is straightforward and is nearly the same as in the supervised setting. The CS 330 slides defines the following sequence:</p>
<ol type="1">
<li>Sample mini-batch of tasks <span class="math inline">\(\mathscr{B} \sim\left\{\mathscr{T}_i\right\}\)</span></li>
<li>Sample mini-batch datapoints for each task <span class="math inline">\(\mathscr{D}_i^b \sim \mathscr{D}_i\)</span></li>
<li>Compute loss on the mini-batch: <span class="math inline">\(\hat{\mathscr{L}}(\theta, \mathscr{B})=\sum_{\mathscr{T}_k \in \mathscr{B}} \mathscr{L}_k\left(\theta, \mathscr{D}_k^b\right)\)</span></li>
<li>Backpropagate loss to compute gradient <span class="math inline">\(\nabla_\theta \hat{\mathscr{L}}\)</span></li>
<li>Apply gradient with your favorite neural net optimizer</li>
</ol>
<p>Note: one place where multi-task loss &amp; optimization differ from the traditional supervised learning paradigm is that we can weight the tasks differently. That is, we can weight the losses differently corresponding to different tasks. This is a key hyperparameter to pay attention to in the multi-task setting. Explicity, we can assign more weight (zero-sum total) to a task that we (human) deem as more important. However, we can also realize that, during training, one task might outweigh the others and cause bad performance for the other tasks. As such, it may be a good idea to weight the “weaker” tasks stronger than the “stronger” ones. And by stronger, I mean tasks that, if evenly weighted for all tasks, would dominate the optimization procedure (the model params would be biased towards this task).<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
</section>
</section>
<section id="pytorch-example" class="level2">
<h2 class="anchored" data-anchor-id="pytorch-example">PyTorch Example</h2>
<p>Coming soon… see <a href="https://pyimagesearch.com/2022/08/17/multi-task-learning-and-hydranets-with-pytorch/">this blog post</a> for an example.</p>
</section>
<section id="applications" class="level2">
<h2 class="anchored" data-anchor-id="applications">Applications</h2>
<ul>
<li>Tesla uses a multi-task “hydranet” model for its inference in self-driving cars. The vision-only system takes in a tuple of 8 images from the car’s cameras, passes the concatenated feature vector through a shared backbone encoder, and separates each task via a decoder head. For example, Tesla uses one network for things like depth estimation, lane segmentation, etc. See <a href="https://www.thinkautonomous.ai/blog/how-tesla-autopilot-works/">here</a>.</li>
</ul>
</section>
<section id="confusionsquesions" class="level2">
<h2 class="anchored" data-anchor-id="confusionsquesions">Confusions/quesions</h2>
<ul>
<li>Does the input feature vector need to be the same for each task? (I believe the answer is no)</li>
</ul>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li><a href="https://cs330.stanford.edu/slides/cs330_multitask_transfer_2021.pdf">CS 330</a></li>
<li><a href="https://pyimagesearch.com/2022/08/17/multi-task-learning-and-hydranets-with-pytorch/">Tutorial blog</a></li>
</ul>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Question: can we treat the task weights as actual parameters (not hyperparameters) that we update via the optimization process (either explicitly or implicitly)?<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>